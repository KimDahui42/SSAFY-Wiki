# SOLID원칙

표준화 작업에서부터 아키텍쳐 설계에 이르기까지 다양하게 적용되는 원칙

객체지향 디자인 원리들을 사용하면 유지보수가 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있다.

# **S**RP(Single Responsibility Principle)

### 단일 책임 원칙
’하나의 모듈은 하나의 액터에 대해서만 책임져야 한다’

: 작성된 클래스는 하나의 기능만을 가지며, 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어있어야 한다. 즉, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나 뿐 이어야한다. 

>> 액터란 변경을 요청하는 집단, 모듈은 함수와 데이터구조로 구성된 응집된 집합

>> 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이

>> 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로 연쇄작용에서 자유로울 수 있다.

>> ‘책임’은 하나의 ‘기능 담당’이라 생각하면 됨.

>> 실무 프로세스는 매우 복잡, 다양하고 변경이 빈번하기 때문에 SRP와 멀어지기 쉬움. 평소에 많은 연습(’책임’이라는 단어를 상기하는)과 경험 필요!

### <단일 책임 원칙을 지키지 않았을 때의 문제점>

1. 우발적 중복
SRP를 위반하는 클래스의 사례로 서로 다른 세 명의 액터를 책임지는 Employee클래스를 정의해볼 수 있다.

- calculatePay() 메서드 : 회계팀에서 CFO 보고를 위해 사용
- reportHours() 메서드: 인사팀에서 COO 보고를 위해 사용
- save() 메서드: DBA가 CTO 보고를 위해 사용

<aside>
💡 만약! 1, 2의 메서드가 정규 업무 시간을 계산하는 알고리즘을 공유하며, regularHours()라는 메서드 하나로 공유한다면?!
CFO에서 정규 업무 시간을 계산하는 방식을 수정 요청하고, 수정하는 개발자가 regularHours() 가 양쪽에서 호출한다는 것으 ㄹ모르면 CFO팀에서의 수정이 COO 팀의 로직에 영향을 주게 된다. 
따라서 SRP는 이러한 상황을 방지하기 위해 서로 다른 액터가 의존하는 코드를 분리하라고 말하는 것이다.

</aside>

1. 병합

소스파일에 다양하고 많은 메서드를 포함할 수록, 그리고 이 메서드가 서로 다른 액터를 책임질수록 병합이 발생할 가능성이 높다.

<aside>
💡 CTO팀에서 데이터베이스의 Employee 테이블 스키마를 수정하는 동시에 COO팀에서 reportHours()메서드의 보고서 포맷을 변경하기로 결정한다면 ?!
서로 다른 팀에 속한 개발자가 각자 변경사항을 적용하고, 이 변경사항은 충돌할 것이다. 병합에는 당연히 위험이 뒤따른다.
이도 마찬가리고 서로 다른 액터를 뒷받침하는 코드를 분리해야한다.

</aside>

# OCP(Open Close Principle)

### 개방폐쇄의 원칙
’확장에는 열려있고, 변경에는 닫혀있어야 한다’

: 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 않아야 하며 기존 구성요소를 쉽게 확장해서 재 사용할 수 있어야 한다는 뜻

>> 덜 중요한 쪽이 더 중요한 쪽에 의존해야함!!

>> 즉, 저수준 컴포넌트에서 발생한 변경으로부터 고수준의 컴포넌트를 보호함

>> 시스템을 확장하기 쉬우면서도 변경으로 인해 시스템이 영향 받지 않도록 함

>> 객체지향의 장점을 극대화

>> 인터페이스 설계에서 적당한 추상화 레벨을 선택해야함. ‘추상화’란 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특징을 의미함. 즉, 이 ‘행위’에 대한 본질적인 정의를 통해 인터페이스를 식별해야 함.

# LSP(The Liskov Subsitution Principle)

### 리스코브 치환의 원칙
’서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다’

: 서브 타입은 언제나 기반 타입이 약속한 규약(public 인터페이스, 물론 exception까지)을 지켜야 한다. 상속은 다형성을 통한 확장성 획득을 목표로 하는데, LSP원리도 역시 서브클래스가 확장에 대한 인터페이스를 준수해야 함을 의미. 

>> 서브타입이란?
- S타입 객체 o1 각각에 대응하는 T타입 객체가 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면 S는 T의 서브 타입이다.

<상속을 사용하도록 가이드하기>

License 클래스는 calcFee()라는 메서드를 가지며, Billing 애플리케이션에서 이 메서드를 호출한다고 가정해보자. License 를 구현한 서브 타입 PersonalLicense와 BusinessLicense 는 서로 다른 알고리즘을 이용해 라이선스 비용을 계산한다. 이 상황에서 Billing 애플리케이션의 행위는 License 서브 타입 중 무엇을 사용하는지에 의존하지 않기 때문에 이 서브 타입은 모두 License타입을 치환할 수 있다. 따라서 이 설계는 LSP를 준수한다.

<정사각형/직사각형 문제>

LSP를 위반하는 전형적인 문제이다. Rectangle 클래스는 가로, 세로 길이를 변경하는 setH, setW 메서드를 가지고 있다. 이 클래스의 서브 타입으로 Square를 구현했다고 가정해보자. 이 예제에서 Square의 높이와 너비는 반드시 함께 변경되어야 하기 때문에 Rectangle의 서브 타입으로 적합하지 않다. Rectagle이 Square인지 검사하는 매커니즘을 추가하는 등의 방법으로 해결할수는 있겠지만, 이렇게 하면 user의 행위가 사용하는 타입에 의존하게 된다.

..

후..잘이해안되어서.. 그냥 arrayList 는 List를 상속받고 있는데, 입력 받을 때나 출력할 때 arrayList대신 List로 해도 문제가 없다.. 정도로 이해하면 될 것 같슴다.. 다형성을 통한 확장성이 키워드!!

# ISP(Interface Segregation Principle)

### 인터페이스 분리의 원칙
’하나의 일반적인 인터페이스보다는, 
여러 개의 구체적인 인터페이스가 낫다’

: 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함. 즉, 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 함. SRP가 클래스의 단일 책임을 강조한다며느 ISP는 인터페이스의 단일 책임을 강조함! 

>> 인터페이스 분리를 통해 변화에 대한 적응성을 획득함
>> 불필요한 의존성을 제거해야한다는 원칙

![Untitled](SOLID%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a3646a89246646cb9a9c40916758a171/Untitled.png)

user1는 op1만, 2는 2만 3는 3만 쓴다고 가정했을 때 불필요한 의존성이 너무 많음.

**User1 프로그램의 입장에서 ISP 원칙 적용을 위한 사고흐름.
1.** User1에서 OPS의 op1함수를 사용하고 있군,, OPS는 어떤 클래스인지 살펴보자!
2. 엇, OPS에서 op1 말고 다른 함수들도 있구나... (op2는 User2가 사용하고, op3는 User3가 사용을 하고있네.)
3. op1 말고 다른 함수가 변경이 된다면 User1도 쓸데없이 다시 컴파일하고 배포해야하잖아???
4. OPS랑 User1을 분리해야겠어. U1Ops 인터페이스로 결합도를 낮춰보도록하자!
5. 이렇게 하면 OPS에 직접적으로 의존하지도 않고, op1 함수외에 다른 변경에는 영향을 받지 않으니 ISP가 잘 적용되었구나.

![Untitled](SOLID%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a3646a89246646cb9a9c40916758a171/Untitled%201.png)

# DIP(Dependency Inversion Principle)

### 의존성역전의 원칙
’소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템’

: 객체는 저수준 모듈보다 고수준 모듈에 의존해야함. 즉, 구현된 객체보다 인터페이스와 같은 객체의 형태나 추상적 개념에 의존해야 한단 의미. 

>> 변동성이 큰 구체 클래스를 참조하지 말자. 대신 추상 인터페이스를 참조하자.

>> 변동성이 큰 구체 클래스로부터 파생하지 말아라.

>> 구체 함수를 오버라이드 (함수 덮어쓰기) 하지 말자. 차라리 추상함수로 선언하고 구현체들에서 구현하자

>> 구체적이며 변동성이 크다면 절대로 이름을 언급하지 말자!