# SOLID 원칙

태그: 디자인패턴
CS 주제:  [2주차] 디자인패턴 (https://www.notion.so/2-a262137b3eba4db79de885eca3e85e38?pvs=21)
날짜: 2023년 8월 7일
블로그 게시: No
완료: Yes
작성자: sun
참고자료: https://hyoje420.tistory.com/14, https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID, https://mangkyu.tistory.com/194
출석: 230807 출석 (https://www.notion.so/230807-e69f8e83c06c4b238938f08f419c73c7?pvs=21)

## 원칙 - SOLID (객체지향 설계 원칙)

- 로버트 C.마틴이 명명한 객체지향 프로그래밍 및 설계의 기본 원칙
- 코드를 확장하고, 유지보수 관리가 쉬워짐
- 불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄임으로써 개발의 생산성 ↑

### 시작에 앞서

Q. SOLID 원칙에 적용 순서가 있나요?

A. SOLID 원칙에는 별도의 적용 순서가 없다

Q. 프로젝트에 반드시 5개의 원칙이 모두 적용되어야 하나요?

A. 프로젝트에 적용할 원칙의 수는 구성에 따라 상이하다. 각 원칙은 특정 문제 해결을 위한 지침일 뿐, 만일 코드에 해당 문제가 없다면 굳이 적용할 이유가 없다.

### 1. Single Responsibility Principle (단일 책임 원칙)

![Untitled](SOLID%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a163e2998a2641d59a87e7f20bd680b8/Untitled.png)

- 하나의 클래스는 하나의 기능만 할 것

- 응집도는 높게, 결합도는 낮게 설계 (유지보수성을 높이기 위한 설계)

- 객체에 변경이 생길 경우, 책임을 나누지 않으면 해당 기능을 사용하는 모든 부분을 다시 테스트 해야 하므로 한 가지 역할만 분배하여 서로 간의 영향을 최소화 할 것
    - 이를 잘 지키면, 변경이 필요할 때 수정할 대상이 명확해짐
    - 적절하게 코드를 분리하여 서로 영향을 주지 않도록 추상화 ⇒ 변화에 손쉽게 대응
        - 추상화
            
            객체의 공통적인 속성과 기능을 추출하여 정의하는 것
            
            어떤 객체가 수행해야 하는 핵심적인 역할만 규정해두고, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록 프로그램을 설계 **(역할과 구현의 분리)**
            

- Ex > 청소기 클래스
    - 청소기 클래스는 청소 메소드만 잘 구현!
    - 화분에 물을 주거나 드라이를 할 책임은 가지지 않는다!!
    - 다재다능한 청소기는 좋아보일 수 있지만, 청소기가 고장날 경우에는 물도 못주고 드라이도 못함 ㅠㅠ
    - 청소기는 청소만 잘하면 된다는 책임을 가지고, 그것만 잘!!! 수행하도록~

### 2. Open - Close Principle (개방-폐쇄 원칙)

![Untitled](SOLID%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a163e2998a2641d59a87e7f20bd680b8/Untitled%201.png)

- 확장(상속)에는 개방적이고, 수정에는 폐쇄적일 것
    - 확장에 개방 : 요구사항이 변경될 때 유연하게 코드를 추가하여 어플리케이션의 기능을 확장
    - 수정에 폐쇄 : 기존 코드를 직접적으로 수정하지 않고 어플리케이션의 동작을 추가 or 변경
        
        ⇒ 여러 객체에서 사용하는 동일한 기능을 인터페이스에 정의하는 방법 (캡슐화)
        
        - 캡슐화
            
            클래스 안에 ****서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것
            
    
- 결국, **추상화 사용을 통한 관계 구축**을 권장!!
    
    ⇒ 다형성과 확장을 가능케 함으로써 객체지향의 장점을 극대화하는 기본적인 설계 원칙 
    

### 3. Liskov Substitution Principle (리스코프 치환 원칙)

![Untitled](SOLID%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a163e2998a2641d59a87e7f20bd680b8/Untitled%202.png)

- 자식이 부모의 자리를 대체할 수 있을 것 (**다형성**의 원리 이용)
    
    > 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조
    > 
    
    ⇒ 대체 가능성을 결정해야 하는 것은 해당 객체를 이용하는 클라이언트임
    
- 자식 클래스는 부모 클래스의 책임에 대해 무시하거나 재정의 하지 않고, 확장만 수행
    
    > 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도, 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 함
    > 
    
- 오버라이드는 가급적 피하고, 사용 시 예외 처리를 잘할 것
    
    > 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있음
    > 
    - 오버라이드
        
        부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것
        
        상속받은 메소드를 그대로 사용할 수도 있지만, ***자식 클래스에서 상황에 맞게 변경***해야하는 경우 오버라이딩할 필요가 생긴다.
        
    - 오버로드
        
         한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 ***매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의***할 수 있다.
        

### 4. Interface Segregation Principle (인터페이스 분리 원칙)

![Untitled](SOLID%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a163e2998a2641d59a87e7f20bd680b8/Untitled%203.png)

- 목적과 관심이 다른 클라이언트가 있다면, 인터페이스를 통해 적절히 분리

- 인터페이스가 잘 분리되어, 클래스가 꼭 필요한 인터페이스만 구현하도록 할 것
    
    ⇒ 모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스(외부에서 접근 가능한 메세지)만을 접근하여 불필요한 간섭을 최소화!
    

- 하나의 거대한 인터페이스보다 여러 개의 구체적인 인터페이스가 나음

- 단, 한 번 인터페이스를 분리하여 구성해 놓고 나중에 무언가 수정 사항이 생겨 또 인터페이스들을 분리하는 행위는 안됨! (한 번 구성했으면 변경을 지양할 것)

### 5. Dependency Inversion Property (의존 역전 원칙)

![Untitled](SOLID%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20a163e2998a2641d59a87e7f20bd680b8/Untitled%204.png)

- 어떤 Class를 참조해서 사용해야 하는 상황이 생길 경우, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조할 것!

- 상위 모듈이 하위 모듈에 의존하지 않을 것
    - 상위 모듈 : 입력과 출력으로부터 먼(비즈니스와 관련된) 추상화된 모듈
    
- 하위 모듈은 상위 모듈에 의존할 것
    - 하위 모듈 : 입력과 출력으로부터 가까운(HTTP, 데이터베이스, 캐시 등과 관련된) 구현 모듈
    
- 의존 관계는 변화가 어렵거나 변화가 거의 없는 것과 맺을 것

- 두 모듈 모두 추상화에 의존하며, 추상화는 세부 사항에 의존하지 않을 것 **(결합도를 낮추기 위한 설계 원칙)**

## 결국, 핵심은 추상화와 다형성!!!