# 디자인 패턴

태그: 디자인패턴
CS 주제: [1주차] 디자인패턴 (https://www.notion.so/1-f1717caf520f4af7aecf1150103f5e7a?pvs=21)
날짜: 2023년 7월 30일
블로그 게시: No
완료: Yes
작성자: sun
참고자료: https://da-nyee.github.io/posts/design-pattern-solid-principles/, https://gmlwjd9405.github.io/2018/07/06/design-pattern.html, https://gyoogle.dev/blog/design-pattern/Overview.html, https://readystory.tistory.com/114

# 디자인 패턴 개요

: 특정 상황에서 반복적으로 발생하는 문제 패턴을 발견하고, 해결 방안을 기록으로 남기는 것

- 특징
    - 디자인 패턴은 특정한 구현이 아닌, 아이디어
    - 필수 적용 사항은 아님
    - 재사용, 호환, 유지보수 시 발생하는 문제를 예방하기 위해 패턴을 정형화해 둔 것
    
- 요소
    - 패턴 이름
        - 해당 패턴의 솔루션을 담은 이름으로 작성
    - 문제
        - 패턴 사용 케이스를 서술하며 해결할 문제와 배경을 제시
    - 해법 및 구현
        - 문제에 대한 해결책 제시 및 예제 코드를 통한 구현
    - 결과
        - 디자인 패턴 적용 시 얻는 결과와 장단점을 서술

## 원칙 - SOLID (객체지향 설계 원칙)

- 로버트 C.마틴이 명명한 객체지향 프로그래밍 및 설계의 기본 원칙

### 1. Single Responsibility Principle (단일 책임 원칙)

- 하나의 클래스는 하나의 역할만 할 것
- 응집도는 높게, 결합도는 낮게 설계
- 객체에 변경이 생길 경우, 책임을 나누지 않으면 해당 기능을 사용하는 모든 부분을 다시 테스트 해야 하므로 한 가지 역할만 분배하여 서로 간의 영향을 최소화 할 것

### 2. Open - Close Principle (개방-폐쇄 원칙)

- 확장(상속)에는 개방적이고, 수정에는 폐쇄적일 것
- 기존 코드에 기능을 추가하되, 변경은 하지 않아야 함
    
    ⇒ 여러 객체에서 사용하는 동일한 기능을 인터페이스에 정의하는 방법 (캡슐화)
    

### 3. Liskov Substitution Principle (리스코프 치환 원칙)

- 자식이 부모의 자리를 대체할 수 있을 것
- 자식 클래스는 부모 클래스의 책임에 대해 무시하거나 재정의 하지 않고, 확장만 수행
- 오버라이드는 가급적 피하고, 사용 시 예외 처리를 잘할 것

### 4. Interface Segregation Principle (인터페이스 분리 원칙)

- 인터페이스가 잘 분리되어, 클래스가 꼭 필요한 인터페이스만 구현하도록 할 것
- 하나의 거대한 인터페이스보다 여러 개의 구체적인 인터페이스가 나음]

### 5. Dependency Inversion Property (의존 역전 원칙)

- 상위 모듈이 하위 모듈에 의존하지 않을 것
- 의존 관계는 변화가 어렵거나 변화가 거의 없는 것과 맺을
- 두 모듈 모두 추상화에 의존하며, 추상화는 세부 사항에 의존하지 않을 것

## 패턴의 분류

### 1. 생성 패턴 (Creational Pattern)

- 객체의 생성 방식 결정
    
    : 객체의 생성과 조합을 캡슐화 하여 특정 객체가 생성되거나 변경되어도 프로그램 구조에 크게 영향을 받지 않도록 유연성을 제공
    
    - 추상 팩토리 메서드 (Abstract Factory Methods)
        
        : 관련된 부품을 조립해서 제품을 만든다.
        
    - 팩토리 메서드 (Factory Methods)
        
        : 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
        
    - 싱글톤 (Singleton)
        
        : 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든 참조할 수 있도록 하는 패턴
        

### 2. 구조 패턴 (Structural Pattern)

- 객체 간의 관계를 조직
    
    : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
    
    Ex > 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터펫이스를 제공하거나 객체들을 서로 묶어 새로운 기능 제공
    
    - 컴퍼지트(Composite)
        
        : 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
        
    - 데커레이터(Decorator)
        
        : 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴
        

### 3. 행동 패턴 (Behavioral Pattern)

- 객체의 행위를 조직, 관리, 연합
    
    : 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배할지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점
    
    - 옵서버(Observer)
        
        : 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴
        
    - 스테이트(State)
        
        : 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴
        
    - 스트래티지(Strategy)
        
        : 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
        
    - 템플릿 메서드(Template Method)
        
        : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
        
    - 커맨드(Command)
        
        : 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
        

# 클래스와 객체, 인스턴스

![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%2016965dfd8c484c8fbbeb75dc84246139/Untitled.png)

## 클래스

- 객체를 생성하기 위한 일종의 설계도
- 객체가 가지는 속성(필드)과 동작(메서드)로 이루어져 있다
    - 생략될 수도, 하나 이상 작성될 수도 있음.

## 객체

- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 “자신의 속성을 가지고, 다른 것과 식별 가능한 것”을 말한다
- 소프트웨어 세계에 구현할 대상

## 인스턴스

- 클래스를 통해 생선된 객체 하나하나를 해당 클래스의 인스턴스라 한다.
- 클래스를 통해 힙 영역에 새로운 인스턴스(객체)를 생성할 수 있다.
    - 인스턴스는 결국 현실의 객체를 소프트웨어 내에서 구현한 실체 (메모리에 할당)
    
- 특징
    - 인스턴스는 객체에 포함된다
    - OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라 부른다
    - 추상적인 개념과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한