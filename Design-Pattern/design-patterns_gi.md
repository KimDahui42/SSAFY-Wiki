# design patterns

태그: 디자인패턴
CS 주제: [1주차] 디자인패턴 (https://www.notion.so/1-f1717caf520f4af7aecf1150103f5e7a?pvs=21)
날짜: 2023년 7월 30일
블로그 게시: Yes
완료: Yes
작성자: 김지연
참고자료: https://refactoring.guru/, https://wikidocs.net/69361
출석: 230730 출석 (https://www.notion.so/230730-937cbc74cc354eb1a0a1617b3e003054?pvs=21)

> 디자인 패턴이란?
> 

소프트웨어 디자인 과정에서 자주 발생하는 문제들에 대한 전형적인 해결책

코드에서 반복되는 디자인 문제를 해결하기 위해 미리 만들어진 청사진 blueprint

패턴은 정해져있는 코드 조각이 아니라, 어떻게 해결해야 하는지 알려주는 일반적인 개념이다

> 패턴의 분류
> 

1. **생성** 패턴 - 기존 코드의 재활용과 유연성을 증가시키는 객체 생성 매커니즘 제공

2. **구조** 패턴 - 구조를 유연하고 효율적으로 유지하면서, 객체와 클래스를 더 큰 구조로 조합하는 방법 설명

3. **행동** 패턴 - 객체 간의 효과적인 의사소통과 책임 할당 처리

> 생성 패턴
> 

기존 코드의 유연성과 재사용을 증가시키는 객체를 생성하는 다양한 방법 제공

- **팩토리 메서드** : 부모 클래스에서 객체를 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체의 유형을 변경할 수 있도록 한다.
- 추상 팩토리 : 관련 객체들의 구상 클래스들을 지정하지 않고도 패밀리를 생성할 수 있다.
- 빌더 : 복잡한 객체들을 단계별로 생성할 수 있다. 이 패턴은 같은 생성코드를 사용하여 객체의 다양한 유형들과 표현을 생성 가능
- 프로토 타입 : 코드를 클래스에 의존시키지 않고, 기존 객체를 복사할수 있게 함
- **싱글턴** : 클래스에 인스턴스는 하나만 있게 하며, 이 인스턴스에 대한 전역 액세스 지점을 제공한다.

> 구조 패턴
> 

구조를 유연하고 효율적으로 유지하면서 객체들과 클래스들을 더 큰 구조로 조립하는 방법을 설명함

- **어댑터** : 호환되지 않는 인터페이스를 가진 객체들이 협업할수 있게 함
- 브리지 : 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층 구조(추상화 및 구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 함
- **복합체 composite** : 객체들을 트리 구조로 구성한 후, 이러한 트리 구조들이 개별 객체인 것처럼 작업할 수 있게하는 디자인패턴
- 데코레이터 : 객체들을, 새로운 행동을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결시킨다
- 파사드 : 라이브러리에 대한, 프레임 워크에 대한, 또는 다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스 제공
- 플라이웨이트: 각 객체들에 모든 데이터를 유지하는 대신 여러 객체 간에 상태의 공통부분들을 공유하여 사용할 수 있는 RAM에 더 많은 객체를 포함할 수 있도록 한다
- 프록시 : 다른 객체에 대한 대체 혹은 자리표시자를 제공한다. 프록시는 원래 객체에 대한 접근을 제어하므로, 요청이 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있게 한다

> 행동패턴
> 

알고리즘들 및 객체 간의 책임 할당과 관련

- 책임 연쇄 : 핸들러들의 체인을 따라 요청을 전달. 각 핸들러는 요청을 받으면 요청을 처리할지, 다음 핸들러로 전달할지를 결정한다.
- 커맨드: 요청을 독립실행형 객체로 변환한다. 다양한 요청들이 있는 메서드들을 인수화하며, 요청의 실행을 대기열에 넣거나 실행 취소 작업도 지원.
- 반복자 : 컬렉션의 요소들의 기본 표현(리스트, 스택, 트리 등)을 노출하지 않고 순회.
- **중재자** : 객체 간의 혼란스러운 의존 관계를 줄여준다. 객체 간 직접 통신을 제한하고 중재자 객체를 통해서만 협력하게 함
- 메멘토 : 객체의 구현 세부 사항을 공개하지 않으면서 해당 객체의 이전 상태를 저장하고 복원
- **옵저버** : 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 구독 메커니즘을 정의
- 상태 : 객체의 내부 상태가 변경될 때 행동을 변경. 객체가 행동을 변경할 때 클래스를 변경한 것처럼 보이기도 함
- **전략 strategy** : 알고리즘들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 객체들을 상호교환 가능케함
- **템플릿 메서드**: 부모 클래스에서 알고리즘의 골격을 정의하지만, 해당 알고리즘의 구조를 변경하지 않고 자식 클래스들이 알고리즘의 특정 단계들을 오버라이드(재정의)
- 비지터 : 알고리즘들을 객체들로부터 분리.